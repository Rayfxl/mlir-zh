# 开发人员指南

本文档试图描述 MLIR 中使用的一些开发者策略（如使用的编码标准）以及开发方法（如测试方法）。

## 风格指南

MLIR 遵循 [LLVM 风格](https://llvm.org/docs/CodingStandards.html) 指南。我们还遵守以下内容（与 LLVM 风格指南不同或未在 LLVM 风格指南中指定的内容）：

- 采用 [驼峰命名法](https://llvm.org/docs/Proposals/VariableNames.html);

- 在顶层和类成员定义中使用 Doxygen 风格（`///`）注释，无论它们是否作为公共 API 可见。

- 除 IR 单元（Region、Block 和 Operation）外，不可为空的输出参数一般通过非 const 引用传递。

- IR 结构不是为[常量正确性](../Code%20Documentation/Rationale/Usage%20of%20`const`%20in%20MLIR,%20for%20core%20IR%20types.md)而设计的。

- 如果递归无法静态界定，请勿使用递归算法：也就是说，如果存在可能触发堆栈溢出的 IR 输入（例如以递归方式遍历use-def链），请避免递归。目前，我们容忍以下两种情况：

  - IR 嵌套：在遍历嵌套区域时，我们使用递归。
  - 类型嵌套：递归可用于复合类型的嵌套。
  
- [提交信息](How%20to%20Contribute.md)遵循 git 规范。

请使用根目录下的 `.clang-format` 配置文件在修改过的文件上运行 clang-format。有关将 clang-format 与开发环境集成的更多详情，请查阅 clang-format [文档](https://clang.llvm.org/docs/ClangFormat.html)。尤其是，如果 clang 已在整个系统中安装，运行 `git clang-format origin/main` 就会更新工作目录中的文件，使其具有相关的格式化修改；别忘了在提交时包含这些修改。

## IR 在每个pass之前和之后都应该有效

Passes应假定其输入的 IR 已通过验证。Passes不应检查由验证器保证的不变量。如果许多passes都在检查相同的不变量，则应考虑在验证器中添加该不变量，或对 IR 设计/方言进行分解，以便在编译的每个阶段更好地对不变量进行建模。

同样，pass运行后的 IR 也应是验证器有效的。如果一个pass产生的 IR 不能通过验证，那么这个pass就有问题。

在执行pass时，瞬时存在无效 IR 的情况比较常见。这在一定程度上是不提倡的，但实际上往往会这样。

## passes中的断言和崩溃

在经过验证器确认为有效的IR上运行一个MLIR pass 时，理论上不应该引发崩溃或断言失败。如果确实能够引发这些问题，那么说明该pass本身存在缺陷。

如果pass需要验证器无法保证的额外不变量，那么它应自行检查这些不变量，如果这些不变量不存在，则要么安全地不执行变换（对于纯优化passes），要么发出诊断信息，解释为什么不能执行变换（对于需要变换才能保证正确性的降级passes）。

## Pass名称和其他命令行选项

为避免不同方言提供的选项之间发生冲突，一般来说，命名约定是在每个特定方言的passes和选项前加上方言名称。特定pass的选项也应以pass名称为前缀。例如，仿射方言提供了一个循环平铺pass，在命令行中注册为`-affine-tile`，并带有一个平铺尺寸选项，可以用`-affine-tile-size`来设置。

我们还避免使用`cl::opt`来提供pass选项，而是采用[pass 选项](../Code%20Documentation/Pass%20Infrastructure.md)机制。这允许在pass管道描述中序列化这些选项，还可以将不同的选项传递给同一管道中的多个pass实例。

## IR 验证器

省流：只验证一个操作的局部层面信息，尤其是不要遵循def-use链（不要查看任何操作数的生产者或任何结果的使用者）。

MLIR 鼓励在验证器中对操作强制执行不变量。在[ODS](../Code%20Documentation/Defining%20Dialects/Operation%20Definition%20Specification%20(ODS).md)中定义的操作通常会对其接受的操作数类型或操作数与结果之间的关系施加约束。例如，`arith`方言中的操作定义了`SameOperandsAndResultType`特征，它强制执行一个自描述的不变量。

当不变量失效时，我们会将 IR 视为“无效”，并中止编译流程。按照约定，编译器中任何pass默认都假定其输入的 IR 是有效的，并且必须产生有效的输出。pass管理器的默认设置是在每个pass之间强制执行这一规则。由于当验证器失败时会终止整个流程，因此它们必须只对确定被破坏的不变量进行验证，而不是对“可能无效”的情况进行验证。

我们鼓励尽可能多地验证不变量，以便在开发过程中尽快捕捉错误，但也有一些重要方面需要注意。特别是如何处理“未定义行为”的情况，这是一个常见的困惑点。例如`tensor.dim`操作：

```
// 返回以 %dim 为索引的 %A 的维数。
%y = tensor.dim %A, %dim : memref<4x?xf32>
```

`%dim`表示要返回的维度。如果维度索引超出范围，则行为未定义。那么：

```
%ten = arith.constant 10 : index
%y = tensor.dim %A, %ten : memref<4x?xf32>
```

我们在这里显然违反了规范，我们可以静态验证它。然而，这并不是在验证器中强制执行的那种不变量，因为它依赖于非局部特性，这使得编译器的设计不太灵活。例如：

```
  %five = arith.constant 5 : index
  %ten = arith.addi %five, %five : index
  %y = tensor.dim %A, %ten : memref<4x?xf32>
}
```

如果IR是有效的，那么对`arith.addi`进行常量折叠会导致上述情况。如果我们将此视为无效 IR，则意味着`arith.addi`的常量折叠器存在错误：它将有效 IR 变成了无效 IR。同样的情况也适用于许多其他变换（例如内联）。

这就是为什么编写验证器的准则是坚持使用操作的局部信息（想想“当我单独打印这个操作时看到的内容”）。查看操作数或结果是极不寻常的，应予以避免。

## 测试指南

测试指南请参见[此处](Testing%20Guide.md)。

## 贡献新方言（或重要组件）的指南

要贡献一种方言（或 MLIR 中的一个重要组件），通常要写一份“RFC”概述（可以是几个非正式的段落），并将其发送到 MLIR 邮件列表。在接受 MLIR 的新组件时，社区也接受了维护该组件的责任。在评估方言是否适合 MLIR 核心库时，应考虑以下几点：

- 方言的总体目标是什么？第一个实施里程碑是什么？
- 它如何融入 MLIR 方言生态？
  - 连接：它如何与编译管道中的现有方言连接？
  - 整合：是否已经有目标相似或抽象匹配的方言；如果有，是否可以改进而不是添加新方言？
  - 重用：如何将其推广到类似但略有不同的用例？
- 它所服务的用户群体是什么？
- 除了提出方言的人之外，谁是未来的贡献者/维护者？

在实际操作方面，我们希望代码能遵循本文档的其他部分，并强调文档与源代码的一致性。

最好把你的方言/组件以可以单独审查的小增量补丁的形式向上游提交。也就是说，在就最初的 RFC 达成一致后，我们鼓励通过更快的树内迭代来逐步构建方言；只要它们能明确朝着其里程碑和目标发展即可。

我们已经看到了以下几大类方言：

- 对 MLIR 外部的表示进行建模的边缘方言。例如 LLVM、SPIR-V 方言、TensorFlow、XLA/HLO等等。这些方言可能更适合包含原始表示的项目，而不是添加到 MLIR 仓库中。特别是，因为 MLIR 不会对其他项目产生外部依赖。
- 结构化抽象方言，用于概括其他几种方言的共同特征或引入一种编程模型。概括性有时表现为将几种方言低于或源于一种新方言。虽然额外的抽象可能是有用的，但它们应与方言生态的额外复杂性进行权衡。抽象方言的例子包括 GPU 和 Loop 方言。
- 用作程序变换的输入/输出的变换方言。引入这些方言通常是为了在 IR 中具体化变换的前置和后置条件，而条件可以通过分析或通过操作语义获得。例如 Affine、Linalg 方言。

虽然这种分类有助于确定提案的目标，但并非详尽无遗，也不是绝对的，社区愿意讨论这种分类法之外的任何新方言。

## 重大变更

MLIR（与 LLVM 类似）不提供任何 C++ 兼容性保证，并倾向于自由重构 API 以支持上游开发。下游用户在拉取新版本的 MLIR 时，需要管理 API 更新。

在进行重大变更时，我们希望以最方便的方式推进变更的审核和实施，同时尽量减少对现有系统的冲击。为了简化审核流程，通常会将重大变更拆分成多个提交。在这些指导原则下，可以逐步实施重大变更，但我们不会仅仅为了迎合下游用户而刻意调整。因此，我们没有为API预设固定的弃用期。一个好的做法是在[Discourse](https://llvm.discourse.group/c/mlir/31)上交流进行此类更改的时间表和计划。

另请参阅[LLVM 关于任何大型变更的一般指导原则](https://llvm.org/docs/DeveloperPolicy.html#making-a-major-change)。