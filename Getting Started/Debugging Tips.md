# 调试技巧

## 检查编译

调试编译过程没有灵丹妙药。标准的调试技术（printf 调试、gdb/lldb、IDE 图形调试器等）当然适用，但以下是特定于 MLIR 的工具，在深入研究通用调试流程之前，这些工具非常有用。这些工具假定你已经将问题简化为可以使用 `mlir-opt` 或其他挂接到 MLIR 选项解析的程序来重现的形式。如果不是这种情况，请参阅下面的“隔离测试用例”部分。

- `-mlir-print-stacktrace-on-diagnostic` 会在发出诊断时打印堆栈跟踪。这对于快速了解pass中发生错误的位置非常有用。
- 在处理验证器错误时， `--verify-each=0` 会关闭验证器，允许查看完整的无效 IR
- `-mlir-print-op-generic`以通用形式打印操作，这与底层的 C++ 数据结构同构。这通常很有用，因为无效的操作在以“优雅形式”打印时经常会崩溃。此外，即使可以打印“优雅形式”，也可能会由于无效操作而给人产生误导，例如无法打印因出错pass而意外添加的额外操作数。
  - 该选项还会影响`op.dump()`的行为。
- 当使用方言转换/模式重写基础设施时，`-debug-only=dialect-conversion`会打印出非常有用的决策跟踪，并说明决策的原因。
- `-debug-only=mydebugtag` 再加上使用`LLVM_DEBUG`工具，可以直接获取正在处理的事情的调试信息。
- `-mlir-elide-elementsattrs-if-larger` 以简化形式打印较大的常量，使 IR 更容易扫描。
- `--mlir-print-ir-after-failure`会在验证失败时打印整个 IR，而不仅仅是失败的操作。

## 隔离测试用例

将问题隔离到可管理的passes集合（最好是单个pass）中进行检查是调试编译器最重要的部分之一，但有时在较大的编译流程中很难做到这一点。

### 提取`.mlir`文件和pass管道。

MLIR 的核心基础设施具有[创建“崩溃重现器”](../Code documentation/Pass Infrastructure.md)的功能，应将此功能添加到编译流程中。此外，您应确保在编译流程的关键点上转储`.mlir`文件，这样即使编译成功（可能是虚假的，如错误编译），也仍有一个起点可以转入`mlir-opt`。

### 隔离出错的pass

一旦有了一个`.mlir`文件和要运行的pass管道（如崩溃重现器文件中转储的），那么应该使用 `mlir-opt` 的 `-mlir-print-ir-before-all` 选项在每个pass之前打印 IR。此外， `-mlir-print-ir-module-scope`和`-mlir-disable-threading` 在这里也很有用。

如果能正确地开发基于 MLIR 的编译器（即注意正确的程序翻译、高质量的验证器以及在无法正确翻译时进行清晰的诊断），那么到目前为止，最常见的一类错误就是发出错误诊断。出现这种情况时，建议的做法是运行所有passes，直到发出错误诊断的pass之前，然后保存一个新的`.mlir`文件，代表运行有问题的pass之前的IR。

如果问题不只是单个pass中的诊断/验证错误，而是更复杂的问题，那么就需要对 `-mlir-print-ir-before-all` 转储进行更多分析，可能的话，在不同的passes中插入额外的调试打印，以查看问题出在哪里。

无论如何，在这一过程结束时，我们最好能得到一个`.mlir`文件和一个可在`mlir-opt`中运行的单个pass（或可管理的passes集合），以便进一步分析。

## 调试重写模式应用程序

### 检测无效的 API 使用

`RewritePattern`通常被贪婪的模式重写驱动程序等应用，或者作为方言转换的一部分应用。这些驱动程序必须知道某个模式修改了 IR 的哪些部分，这样才能安排在同一块 IR 上进一步的模式应用（在贪婪模式重写的情况下），或者是还原重写（在方言转换的情况下）。

在构建贪婪模式重写驱动程序时，可以使用额外检查（`-DMLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS=ON`）来检测未正确使用重写器/模式 API 的那些模式。这些检查会显著降低贪婪重写的速度，因此默认情况下不会激活它们。这些额外检查会检测以下情况：

- 模式返回 “成功”，但未修改 IR。
- 模式返回 “失败”，但修改了 IR。
- 模式直接修改了 IR，绕过了重写器 API。

这些检查都是尽力而为的；它们基于比较操作指纹技术，因此理论上可能会出现误报。同样，当同一段 IR 被多次修改时，可能会漏掉一些违反 API 的操作。

当检测到无效的模式 API 使用时，程序执行将终止。在这种情况下，建议使用`-debug` 重新运行程序，找出哪个模式是最后执行的模式。此外，ASAN 还可以帮助进行调试。举例来说，如果某个模式错误地使用了`Operation::erase`而不是`RewriterBase::eraseOp`，那么在指纹计算过程中，将访问已释放的内存，ASAN 会检测到并给出详细的错误信息。

### 随机化操作选择

无论操作的处理顺序如何，贪婪模式重写都应收敛到相同的 IR。不具备这一特性的重写很脆弱，可能会“卡住”。注意，可以用“benefit”来指定相对的模式顺序，但没有用于操作选择的机制。出于调试目的，可以在构建贪婪模式重写驱动程序时使用工作表随机化（`-DMLIR_GREEDY_REWRITE_RANDOMIZER_SEED=<number>`），这将随机化操作的选择。

## 其他技巧

- 对于printf调试，可以发出诊断信息，而不是使用`llvm::errs()`。例如，使用`op.emitWarning() << "HERE: " << myVariable;`代替`llvm::errs() << "HERE: " << myVariable << "\n";`。这样就可以高亮打印，自动显示操作（及其位置），甚至可以使用`-mlir-print-stacktrace-on-diagnostic`给出堆栈跟踪。

TODO: 测试用例缩减、调试错误编译、二分工具、何时及如何使用二分的一般哲学讨论