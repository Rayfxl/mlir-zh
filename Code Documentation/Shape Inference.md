# 形状推断

这里讨论的形状推断被视为[ShapedType](https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/IR/BuiltinTypes.h)类型推断的一个特定实例。类型约束（至少）有三个轴：1）元素类型；2）秩（包括静态或动态）；3）维度。虽然有些操作在编译时没有固定的形状（例如，输出形状由数据决定），但我们仍然可以了解系统中该操作的一些约束/界限（例如，`tf.where`的输出最多为输入数据的大小）。也就是说，即使不完全了解形状，也可以捕获到更多有价值的约束。

目前，类型推断是使用 [`InferTypeOpInterface`](https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Interfaces/InferTypeOpInterface.td)为操作创建的执行建模，而`InferShapedTypeOpInterface`则用于实现形状和元素类型推断。返回类型通常可以从推导出的返回形状和元素类型（可从 `InferShapedTypeOpInterface`查询）中推导出来，因此张量类型的类型推断可以用 `InferShapedTypeOpInterface`来实现。

- [形状函数](https://mlir.llvm.org/docs/ShapeInference/#shape-functions)
- [测试](https://mlir.llvm.org/docs/ShapeInference/#testing)
- [形状方言](https://mlir.llvm.org/docs/ShapeInference/#shape-dialect)
  - [需求](https://mlir.llvm.org/docs/ShapeInference/#requirements)
  - [讨论](https://mlir.llvm.org/docs/ShapeInference/#discussion)
  - [可能提出的问题](https://mlir.llvm.org/docs/ShapeInference/#possibly-asked-questions)
  - [开放点](https://mlir.llvm.org/docs/ShapeInference/#open-points)
- [WIP/未来考虑](https://mlir.llvm.org/docs/ShapeInference/#wipfuture-considerations)

## 形状函数

C++ 接口是查询和执行形状推断的基本机制，但不是通常指定形状约束的预期方式。

最初，形状推断将使用以下方法通过声明的方式指定：

- 直接对操作的操作数进行约束。例如，限制输入类型必须是张量/向量元素，或元素类型必须是特定类型（例如，计算值大小的输出是元素类型 `i1`）或类（例如，类浮点型）。

- 操作数和操作结果之间的约束。

  - 例如，在操作数和结果之间指定类型/类型成分（形状和元素类型）的相等约束（例如，加法操作的输出类型与输入操作数的类型相同）。

注：C++ 形状函数是一个中间步骤，直到形状方言更加成熟，届时 C++ 函数应成为例外情况。

## 测试

目前，形状推断与类型推断一起通过测试方言中的 `TestReturnTypeDriver` 进行测试。该驱动程序执行两项检查：

1. 验证指定的返回类型是否与推断的类型一致。这种显式检查将被删除，取而代之的是操作验证的一部分。
2. 测试在函数 `testCreateFunctions` 中未明确指定返回类型时创建操作的情况，方法是创建新的二元操作（在 `TestReturnTypeDriver` 中指定的 Op 类），使用 1) `testCreateFunctions` 的所有操作数作为两个操作数，以及 2) 使用函数的输入操作数的组合。

##  形状方言

本节将详细介绍形状类型推断方言（`shape`）。最初的重点将放在描述形状函数的形状函数上，这些函数可以在运行时和编译器中使用（用于构造操作/优化形状，具象化方言的动态分配，包括 TF、TFLite、XLA 和正在讨论的张量计算方言）。

这将侧重于形状函数（例如，确定输出形状的秩和维度）。如shaped容器类型所示，形状将是 3 个组件之一，其他组件是元素类型和属性（目前保持开放状态，以便稍后支持扩展，例如布局或有界形状）。这样就可以将这些信息解耦：

- 并非所有分析都需要所有信息；
- 并非所有形状函数都需要提供所有信息（例如，可以定义一个基类函数，该函数只填充元素类型，但可以与其他函数组合使用）；
- 它允许重用操作的张量表示和 Memref 表示之间的约束；

可以说这些是元数据函数而不是形状函数，有些人认为形状和元素类型是不同的，有些人则认为它们都是形状的一部分。但在我看来，`shape function`是描述性的，而元数据的潜在用途和价值范围可能过于广泛。

### 需求

形状推断函数的需求是由形状推断的需求决定的，但我们认为下面的需求仍然允许自由考虑不同的形状推断方法，因此我们在此不强加特定的形状推断方法。

#### 形状推断函数

- **可表达性** 形状函数需要支持张量的形状不是静态已知的程序（例如， `tensor<16x?xf32>`或`tensor<*xf32>*`）；

- **形状错误检测** 许多操作的操作数都有约束条件。如果未满足约束条件或无法确定是否静态满足约束条件，则可生成运行时检查/断言。

  - 这也符合以下要求：形状函数描述应该可以被编译器和运行时使用。
  - 形状错误函数应易于理解，至少要知道违反了操作的哪项约束。这也要求形状函数的错误信息应可由形状函数的作者配置（例如，作者可以给出失效的语义约束，而不是失败的低级检查）。
  - 静态分析可用于消除确保通过的运行时检查。
    - 理想情况下，所有检查最终（参见[内联形状检查](https://mlir.llvm.org/docs/ShapeInference/#inline)）都会被省略。
  - 只报告运行时一定会出现的错误。如果错误只是可能发生的（而不是保证发生的），那么我们将使用运行时断言来表示失败，并生成一条错误信息，说明违反了不变量。

- 编译器和运行时均可使用的形状函数。

  - 这并不意味着使用完全相同的 C++ 函数，而是描述应能被编译器和运行时使用。
  - 形状函数描述不应受运行时或编译器类型系统的限制，以处理仅用于分析的类型。也就是说，这两种类型系统各不相同，都应得到支持，但并不要求它们之间有交集。举个具体的例子，如果编译器只想区分精确形状和动态形状，那么即使形状描述支持更通用的形状网格，编译器也不需要考虑它。

- 声明式（例如，可在编译时进行分析，可为不同用例生成不同版本）

  - 这可能不是严格意义上的要求，但却是处理前者的一种方法：鉴于这两个系统具有或将具有不同的类型，声明式规范可以同时被这两个系统重用，同时避免与第 3 种表示形式之间进行映射的需要。

- 可在运行时表达形状推断函数

  - 用户可以在运行时动态定义新操作的形状函数，这样供应商就可以动态描述操作和形状函数。

    这一需求已列入愿望清单。

- 不需要整个图的形状信息（例如，只需要局部信息）

  - 每次启动内核时，形状函数的调用成本应该很低。
  - 形状函数只能由参数（操作数、属性和区域）决定（例如，可以构造和调用与相应操作相同的操作数）。
  - 需要更高级别/图信息的形状信息应使用更丰富的类型（如`TensorList<F32>`）；
  - 函数应可在构造操作之前/同时调用（例如，不能依赖于正在构造的操作）。

- 形状函数应为纯函数。

- 应支持类型只能动态已知的函数（例如，`read_from_file`操作）

  - 无需调用操作（例如，为确定形状而读取一次文件，然后发布以便能够实际使用文件的输出）

- 形状函数操作方言应能与非形状函数方言操作互操作。

  - 我们可能会发现一组能满足大多数用途的通用操作（如merge、equal_type、算术表达式、slice、concat、属性（如padding等）的模式匹配），这些操作可能会涵盖很大一部分用例。其中有些会携带额外的语义信息，可用于符号约束（例如，检查两个维度的相等性，从而设置相等约束）和约束求解的高阶解释。

    因此，重用操作是有益的（但不是必须的），特别是对于静态已知的形状，仍然可以执行任意的算术计算。这就意味着，任意求解器可能支持、也可能不支持静态执行的计算，但仍然是允许的。

- 形状函数应具有可扩展性，从而可以表示符号相等和上限约束（例如），并可通过形状推断进行传播。

  - 例如，形状函数可以包含更多信息，这些信息只有在形状推断中使用时才有用；

- 允许形状函数失败并报错。错误报告应报告操作失败的位置，并尽可能提供用户可操作的错误信息。

  - 这些失败可能会被内联，成为带有运行时值和错误信息的运行时失败。
  - 报告错误应是可选的。例如，可以使用相同的函数来查询有效性，而无需报告错误。

#### 非目标

1. 形状方言是一种 IR 表示法，而不是编程语言；
   - 虽然函数应该是可读的，但它不具备编程语言的便利性。决定人们如何编写这些东西，例如迷你 dsl、生成它们的 C++ API、从 `SetShapeFn` 调用中以编程方式提取它们等，仍是待定事项。
2. 描述将使用形状函数的形状推断方法；
   - 我们的目标是，形状函数和从中可以获得的约束条件具有足够的通用性，可以用于各种分析。但我们是否遵循从非常简单（例如，形状输出只使用完全静态的信息，其他均视为无秩）到非常高级（例如，符号常数的表达式树）的方法，可以独立于本提案进行评估，并进行具体的收益分析。
3. 描述生成错误信息的方法；
   - 虽然形状函数可以选择性地发出错误信息，但也可以决定何时发出错误信息。这样就可以决定是否发出错误或发出哪个错误：有文献建议，形状推断的迭代顺序会影响生成的错误信息的质量，而形状函数并不强制要求这样做。
4. 流敏感的形状函数；
   - 为实现可扩展/低成本的形状推断，形状函数不打算提供流敏感信息。这个工具可以作为一些更高阶分析的一部分来构建，这些分析会重用形状函数/由于形状函数而产生的约束条件。
5. 所有静态函数均可用于动态/未知形状；
   - 与使用未知/符号变量进行合理分析相比，使用静态已知形状可以进行更多的计算。

### 讨论

#### 内联形状推断检查

形状函数应该可以降级到运行时的有效性检查。例如，尽可能进行静态验证，但允许生成动态计算形状的指令，或对编译时无法验证的属性回退到运行时检查。这些插入的检查最好只检查静态验证不了的属性。

这些内联调用可能会干扰优化模式/passes（例如，形状推断不应插入干扰优化模式的结构），因此可以推迟到以后再进行（通过另一轮优化、常量折叠、CSE 等，这应该会移除多余的运行时操作）。

### 可能提出的问题

#### ODS操作规范如何？

在 ODS 中，我们一直在记录操作的操作数和属性的约束。如果这些约束足以限制输出形状（例如，`SameOperandAndResultType`或可广播），我们就应从这些约束中生成形状函数。如果没有，则应指定显式的形状函数（拼写待定，但目前正在考虑使用 MLIR 文本形式作为序列化方法）。

#### 为什么不从参考实现中提取形状函数？

将来可以这样做！提取的形状函数将使用形状推断方言，因此我们从这里开始。特别是对于以结构化方式描述的操作，我们可以自动生成形状函数。

#### 如何/用什么语言编写形状函数？

待定。对多种方法和建议持开放态度，从本提案优先考虑的任何语言产生的 IR 开始。

#### 这里建议的形状推断方法是什么？

没有。我们可以在这些方法的基础上再叠加多种不同的形状推断方法。从最基本的（总是返回无秩的），到更有用的（返回常量输入/参数的固定形状），再到更高级的（在符号命名值之间创建代数语句的逻辑连接）。

### 开放点

1. 给定所有静态形状输入后产生动态输出的形状函数是否应特别标记？例如，从文件中读取。

TODO：在此添加示例。

## WIP/未来考虑

形状函数是由属性决定的，可以任意复杂，具有多种规范可能性。相等关系很常见（例如，输出的元素类型与输入的基本类型相匹配，两个输入具有完全相同的类型[基本类型和形状]），因此这些关系应该很容易指定。代数关系也很常见（例如，`[n,m]`和`[n,m]`矩阵沿 0 轴的连接是`[n+n, m]`矩阵），而有些操作只有在特定情况下才有定义的形状（例如，`[a,b]`和`[c,d]`的矩阵乘法只有在`b == c`时才有定义）。

我们将使用操作的参考实现来派生形状函数，而不是指定一个额外的机制来指定形状转移函数。参考实现是通用的，可以支持指定输出形状所需的任意计算。